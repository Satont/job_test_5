### Постановка

Реализовать систему транзакций. Она должна принимать запросы на ввод или вывод денег и заносить их в базу данных. Также она должна отдавать данные по транзакции из бд при запросе инфы по какой-либо транзакции.

Необходимо реализовать http api для внешних потребителей, которые и будут создавать транзакции и просить информацию о них. Как именно будет выглядеть публичный интерфейс - ваше дело. Оцениваться он будет по удобству, понятности, предсказуемости и прочим вещам, которые мы все любим.

Система должна быть доступной и отказоустойчивой, способной жить под высокой нагрузкой - запросы на создание транзакций должны всегда выполнятся рано или поздно, то есть если что-то в сервисе упадёт из-за какого-либо nil pointerа, клиенты не должны терять способность создавать заявки на создание транзакций. Как это реализовать - ваше дело. Рекомендуем использовать брокер сообщений. Ваше решение будет оцениваться по критериям понятности и поддерживаемости - гипотетические члены вашей команды не должны тратить лишнее время на расшифровку вашего замысла, исследуя вашу архитектуру или читая ваш код.

Необходимо использовать postgresql в качестве бд.
Если у вас будет несколько сервисов, которые общаются друг с другом, они _должны_ общаться по grpc.
Если будете использовать брокер сообщений, рекомендуем rabbitmq - с ним намного легче начать работать, чем с кафкой.

Плюсом будет openapi описание вашего публичного api.
Также плюсом будет простой compose-файл для всей инфры


### Решение

![Diagram](https://github.com/Satont/job_test_5/raw/master/.github/assets/db-digram.png)

- Для миграций выбрал [migrate](https://github.com/golang-migrate/migrate), как минималистичное решение, которое полностью подходит для задачи.
- В качестве драйвера postgres использовал [sqlx](https://github.com/jmoiron/sqlx), генерация запросов через query builder [squirrel](https://github.com/Masterminds/squirrel). Хорошая связка, до этого использовал ORM, и после работы с данными инструментами думаю, что ORM больше брать не стану. Понятный, выразительный код без оверхеда в SQL запросах.
- Для хранения денег выбрал decimal.
- Как метод аутентификации потребителей выбрал api ключи, так как в постановке задачи об этом не сказана
- Написал небольшие скрипты для сидинга и пометки транзакций как выполненные.
- Написал интерфейсы для сервисов по взаимодействию с базой, чтобы можно было использовать один интерфейс на обоих микросервисах.
- Написал интерфейс для логера, чтобы при необходимости можно было его подменить.
- Для общения между микросервисами выбрал rabbitmq, так как в нём есть удобный функционал по мониторингу, сохранению необработанных ивентов.
- Выбрал Makefile для описания команд-скриптов. Сам же предпочитаю taskfile на своих проектах, но Makefile более распространён в экосистеме.

## Api

Написал api сервис для принятия запросов от потребителей, где происходит все валидация запроса.

- Выбрал chi в качестве роутера, так как mux более не поддерживается.
- Написал мидлвары на: проверку подлинности переданного api ключа; валидацию post запросов.
- Разделил обработчики запросов на контроллер/сервис.
- В рамках задачи не описано, но я добавил эндпоинт на получение всех транзакций, с параметрами offset, limit, status (для фильтрации по статусу транзакции)

Не понравилось документирование с помощью [go-swagger](https://github.com/go-swagger/go-swagger). В целом в го работы с такими вещами довольно неприятная, так как чаще всего подобные вещи делаются через тэги в страктах, либо через комментарии.  

Так же я бы взял какой-то http фреймворк, вместо роутера, в котором уже есть нужные инструменты логирования, валидации, кеширования, чтения из body.

## Transactions

Микросервис получился очень маленький. По сути он лишь принимает ивент с rabbitmq и создаёт транзакцию в базе, сказать о нём особо нечего, так как основная логика получилась в api.

### Что не сделано, хотя стоило бы

- Тесты. Тесты очень важны, но слабо знаком с тестированием в го. Я примерно представляю как их писать, делал небольшие тесты своего кода в других приложениях, но как написать комплексные - пока не знаю. Следует озаботиться этим вопросом и подтянуть в ближайшее время.
- Я бы добавил эндпоинт на отмену транзакции.

### Процессы

- При входящих запросах проверяю валидность переданного апи ключа.
- При запросе на ввод/вывод при успешной валидации создаю ивент в rabbitmq для последующей обработки в другом микросервисе. Передаваемые данные венесены в общий dto, для того чтобы делать unmarshal/marshal на микросервисах.
- Баланс потребителя вычисляется из всех обработанных транзакций.
- При недостатке баланса - нельзя создать транзакцию на вывод средств.

## Запуск

#### Api, transactions, seeding

```bash
make up
```

Апи ключ тестового потребителя: `5e3e90b4-ec51-4f94-8550-902e3cfa5d6a`

#### Пометка всех транзакций как выполненные (для тестирования руками)

```bash
make mark-processed
```